{
  "id": "animekai",
  "name": "AnimeKai",
  "description": "AnimeKai is an online streaming provider for subbed/dubbes animes in English",
  "manifestURI": "https://raw.githubusercontent.com/kRYstall9/Seanime-streaming-providers/refs/heads/main/src/AnimeKai/manifest.json",
  "version": "1.1.1",
  "author": "kRYstall9",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "en",
  "payload": "/// \u003creference path=\"./online-streaming-provider.d.ts\" /\u003e\n/// \u003creference path=\"./core.d.ts\"/\u003e\n\ninterface GenericResponse {\n    status: number;\n    result: string;\n}\n\ninterface DecryptResponse {\n    status: number;\n    result: {\n        url: string;\n        skip: {\n            intro: [number, number];\n            outro: [number, number];\n        }\n    };\n}\n\ninterface StreamUrl {\n    type: string;\n    url: string;\n}\n\ninterface MegaResponse {\n    status: number;\n    result: {\n        sources: { file: string }[];\n        tracks: {\n            file: string;\n            label: string;\n            kind: string;\n            default?: boolean;\n        }[];\n        download: string;\n    },\n}\n\nclass Provider {\n    api = \"https://animekai.to\";\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"Server 1\", \"Server 2\"],\n            supportsDub: true,\n        };\n    }\n\n    async search(query: SearchOptions): Promise\u003cSearchResult[]\u003e {\n        let normalizedQuery = this.normalizeQuery(query[\"query\"]);\n        console.log(\"Normalized Query: \" + normalizedQuery);\n\n        const url = `${this.api}/browser?keyword=${encodeURIComponent(\n            normalizedQuery\n        )}`;\n\n        try {\n            const data = await this.GETText(url);\n            const $ = LoadDoc(data);\n            const animes: SearchResult[] = [];\n            $(\"div.aitem-wrapper\u003ediv.aitem\").each((_, elem) =\u003e {\n                const id = elem.find(\"a.poster\").attr(\"href\")?.slice(1) ?? \"\";\n                const title = elem.find(\"a.title\").attr(\"title\") ?? \"\";\n                const subOrDub: SubOrDub = this.isSubOrDubOrBoth(elem);\n                const url = `${this.api}/${id}`;\n                console.log(`Found: ${title} - ${url} - ${subOrDub}`);\n\n                const anime: SearchResult = {\n                    id: `${id}?dub=${query['dub']}`,\n                    url: url,\n                    title: title,\n                    subOrDub: subOrDub,\n                };\n\n                animes.push(anime);\n            });\n\n            return animes;\n        }\n        catch (e: any) {\n            throw new Error(e);\n        }\n    }\n\n    async findEpisodes(id: string): Promise\u003cEpisodeDetails[]\u003e {\n        const url = `${this.api}/${id.split('?dub')[0]}`;\n        const rateBoxIdRegex = /\u003cdiv class=\"rate-box\"[^\u003e]*data-id=\"([^\"]+)\"/;\n        try {\n            const pageHtml: string = await this.GETText(url);\n            const idMatch = pageHtml.match(rateBoxIdRegex);\n            const aniId = idMatch ? idMatch[1] : null;\n\n            if (aniId === null) throw new Error(\"Anime ID not found\");\n\n            const token = await this.GETJson\u003cGenericResponse\u003e(`https://enc-dec.app/api/enc-kai?text=${encodeURIComponent(aniId)}`).then(res =\u003e res.result);\n\n            const fetchUrlListApi = `${this.api}/ajax/episodes/list?ani_id=${aniId}\u0026_=${token}`;\n            const ajaxResult: GenericResponse = await this.GETJson(fetchUrlListApi);\n\n            const $ = LoadDoc(ajaxResult.result);\n\n            const episodeData = $('ul.range\u003eli\u003ea').map((_, elem) =\u003e ({\n                name: `Episode ${elem.attr('num')}`,\n                number: parseInt(elem.attr('num')!, 10),\n                data: elem.attr('token')!,\n                title: elem.find('span').text().replace(/\\s/g, ' ')\n            }));\n\n            const episodes: EpisodeDetails[] = await Promise.all(\n                episodeData.map(async (item) =\u003e {\n                    const response = await fetch(`https://enc-dec.app/api/enc-kai?text=${encodeURIComponent(item.data)}`);\n                    const result: GenericResponse = await response.json();\n\n                    return {\n                        id: item.data ?? \"\",\n                        number: item.number,\n                        title: item.title,\n                        url: `${this.api}/ajax/links/list?token=${item.data}\u0026_=${result.result}?dub=${id.split('?dub=')[1]}`\n                    };\n                })\n            );\n\n            return episodes;\n        }\n        catch (e: any) {\n            throw new Error(e);\n        }\n    }\n\n    async findEpisodeServer(\n        episode: EpisodeDetails,\n        _server: string\n    ): Promise\u003cEpisodeServer\u003e {\n        let server = \"Server 1\";\n        if (_server !== \"default\") server = _server;\n\n        const episodeUrl = episode.url.replace('\\u0026', '\u0026').split('?dub')[0];\n        const dubRequested = episode.url.split('?dub=')[1];\n\n        console.log(\"Episode URL: \" + episodeUrl);\n\n        try {\n            const responseText = await this.GETText(episodeUrl);\n\n            const cleanedHtml = cleanJsonHtml(responseText);\n            const subRegex = /\u003cdiv class=\"server-items lang-group\" data-id=\"sub\"[^\u003e]*\u003e([\\s\\S]*?)\u003c\\/div\u003e/;\n            const softsubRegex = /\u003cdiv class=\"server-items lang-group\" data-id=\"softsub\"[^\u003e]*\u003e([\\s\\S]*?)\u003c\\/div\u003e/;\n            const dubRegex = /\u003cdiv class=\"server-items lang-group\" data-id=\"dub\"[^\u003e]*\u003e([\\s\\S]*?)\u003c\\/div\u003e/;\n\n            const subMatch = subRegex.exec(cleanedHtml);\n            const softsubMatch = softsubRegex.exec(cleanedHtml);\n            const dubMatch = dubRegex.exec(cleanedHtml);\n\n            const sub = subMatch ? subMatch[1].trim() : \"\";\n            const softsub = softsubMatch ? softsubMatch[1].trim() : \"\";\n            const dub = dubMatch ? dubMatch[1].trim() : \"\";\n\n            const serverSpanRegex: RegExp =\n                server == \"Server 1\" ?\n                    /\u003cspan class=\"server\"[^\u003e]*data-lid=\"([^\"]+)\"[^\u003e]*\u003eServer 1\u003c\\/span\u003e/ :\n                    /\u003cspan class=\"server\"[^\u003e]*data-lid=\"([^\"]+)\"[^\u003e]*\u003eServer 2\u003c\\/span\u003e/\n\n            console.log(dub, sub);\n\n            const serverMatch = dubRequested === 'true' ? serverSpanRegex.exec(dub) : serverSpanRegex.exec(sub);\n\n            console.log(\"SERVER MATCH\", serverMatch);\n\n            const serverIdDub = serverSpanRegex.exec(dub)?.[1];\n            const serverIdSoftsub = serverSpanRegex.exec(softsub)?.[1];\n            const serverIdSub = serverSpanRegex.exec(sub)?.[1];\n\n            //serverId = serverMatch[1];\n            const tokenRequestData = [\n                { name: \"Dub\", data: serverIdDub },\n                { name: \"Softsub\", data: serverIdSoftsub },\n                { name: \"Sub\", data: serverIdSub }\n            ].filter(item =\u003e item.data !== undefined) as { name: string; data: string }[];\n\n            const tokenResults = await Promise.all(\n                tokenRequestData.map(async (item) =\u003e {\n                    const response = await fetch(`https://enc-dec.app/api/enc-kai?text=${encodeURIComponent(item.data)}`);\n                    return { name: item.name, data: await response.json() as GenericResponse };\n                })\n            );\n\n            const serverIdMap = Object.fromEntries(tokenRequestData.map(item =\u003e [item.name, item.data]));\n\n            const streamUrls: StreamUrl[] = tokenResults.map((result) =\u003e {\n                return {\n                    type: result.name,\n                    url: `https://animekai.to/ajax/links/view?id=${serverIdMap[result.name]}\u0026_=${result.data.result}`\n                };\n            });\n\n            const decryptedUrls = await processStreams(streamUrls);\n\n            const headers = {\n                \"Referer\": \"https://animekai.to/\",\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\"\n            };\n\n            const streamUrl = dubRequested === 'true' ? decryptedUrls.Dub : (decryptedUrls.Sub ?? decryptedUrls.Softsub);\n\n            if (streamUrl == \"\") {\n                throw new Error(\"Unable to find a valid source\")\n            }\n\n            const streams = await fetch(streamUrl.replace(\"/e/\", \"/media/\"), {\n                headers: headers\n            });\n\n            const responseJson = await streams.json();\n            const result = responseJson?.result;\n            const postData = {\n                \"text\": result,\n                \"agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\"\n            }\n\n            const finalJson: MegaResponse = await fetch(\"https://enc-dec.app/api/dec-mega\", {\n                method: \"POST\",\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(postData)\n            }).then(res =\u003e res.json());\n\n            if (!finalJson || finalJson.status !== 200) throw new Error(\"Failed to decrypt the final stream URL\");\n            if (!finalJson.result.sources || finalJson.result.sources.length === 0) throw new Error(\"No video sources found in the final response\");\n\n            const m3u8Link = finalJson.result.sources[0].file;\n            const playlistResponse = await fetch(m3u8Link);\n\n            //Regex to extract all the resolutions and url related to the resolutions available\n            const regex = /#EXT-X-STREAM-INF:BANDWIDTH=\\d+,RESOLUTION=(\\d+x\\d+)\\s*(.*)/g;\n            const videoSources: VideoSource[] = [];\n\n            let resolutionMatch;\n\n            while ((resolutionMatch = regex.exec(await playlistResponse.text())) !== null) {\n\n                let url = \"\";\n\n                if (resolutionMatch[2].includes(\"list\")) {\n                    url = `${m3u8Link.split(',')[0]}/${resolutionMatch[2]}`;\n                }\n                else {\n                    url = `${m3u8Link.split('/list')[0]}/${resolutionMatch[2]}`\n                }\n\n                videoSources.push({\n                    quality: resolutionMatch[1].split('x')[1] + 'p', // 1920x1080 -\u003e 1080p\n                    subtitles: [], //Subs are already integrated in the video source\n                    type: 'm3u8', //Standard type for AnimeKai\n                    url: url\n                });\n            }\n\n            const episodeServer: EpisodeServer = {\n                server: server,\n                headers: {\n                    \"Access-Control-Allow-Origin\": \"*\",\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0'\n                },\n                videoSources: [...videoSources]\n            };\n\n            return episodeServer\n\n        }\n        catch (e: any) {\n            throw new Error(e);\n        }\n    }\n\n    normalizeQuery(query: string): string {\n        let normalizedQuery = query\n            .replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, \"$1\") //Removes suffixes from a number I.e. 3rd, 1st, 11th, 12th, 2nd -\u003e 3, 1, 11, 12, 2\n            .replace(/\\s+/g, \" \") //Replaces 1+ whitespaces with 1 whitespace\n            .replace(/(\\d+)\\s*Season/i, \"$1\") //Removes season and keeps the number before the Season word\n            .replace(/Season\\s*(\\d+)/i, \"$1\") //Removes season and keeps the number after the Season word\n            .trim();\n\n        return normalizedQuery;\n    }\n\n    async _makeRequest(url: string): Promise\u003cResponse\u003e {\n        const response = await fetch(url, {\n            method: \"GET\",\n            headers: {\n                \"DNT\": \"1\",\n                \"User-Agent\":\n                    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0\",\n                Cookie: \"__ddg1_=;__ddg2_=;\",\n            },\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch: ${response.statusText}`);\n        }\n        return response;\n    }\n\n    async GETText(url: string): Promise\u003cstring\u003e {\n        return await this._makeRequest(url).then(res =\u003e res.text());\n    }\n\n    async GETJson\u003cT\u003e(url: string): Promise\u003cT\u003e {\n        return await this._makeRequest(url).then(res =\u003e res.json());\n    }\n\n    isSubOrDubOrBoth(elem: DocSelection): SubOrDub {\n        const sub = elem.find(\"span.sub\").text();\n        const dub = elem.find(\"span.dub\").text();\n\n        if (sub != \"\" \u0026\u0026 dub != \"\") {\n            return \"both\";\n        }\n        if (sub != \"\") {\n            return \"sub\";\n        }\n\n        return \"dub\";\n    }\n}\n\nfunction cleanJsonHtml(jsonHtml: string) {\n    if (!jsonHtml) {\n        return \"\";\n    }\n    return jsonHtml\n        .replace(/\\\\\"/g, \"\\\"\")\n        .replace(/\\\\'/g, \"'\")\n        .replace(/\\\\\\\\/g, \"\\\\\")\n        .replace(/\\\\n/g, \"\\n\")\n        .replace(/\\\\t/g, \"\\t\")\n        .replace(/\\\\r/g, \"\\r\");\n}\n\nasync function processStreams(streamUrls: StreamUrl[]): Promise\u003c{ [key: string]: string }\u003e {\n    const streamResponses = await Promise.all(\n        streamUrls.map(async ({ type, url }) =\u003e {\n            try {\n                const json: GenericResponse = await fetch(url).then(r =\u003e r.json());\n                return { type, result: json.result };\n            } catch (error) {\n                console.log(`Error fetching ${type} stream:`, error);\n                return { type, result: null };\n            }\n        })\n    );\n\n    const decryptResults = await Promise.all(\n        streamResponses\n            .filter(item =\u003e item.result !== null)\n            .map(async item =\u003e {\n                const result: DecryptResponse = await fetch(\"https://enc-dec.app/api/dec-kai\", {\n                    headers: { 'Content-Type': 'application/json' },\n                    method: \"POST\",\n                    body: JSON.stringify({ text: item.result })\n                }).then(res =\u003e res.json());\n\n                return { [item.type]: result.result.url };\n            })\n    );\n\n    return Object.assign({}, ...decryptResults);\n};"
}
